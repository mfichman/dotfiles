#!/usr/bin/env ruby

require 'optparse'
require 'json'
#require 'byebug'

def system(command, exception: true, silent: false)
  $stdout.puts(command) unless silent
  super(command, exception: exception)
end

def user
  user = ENV.fetch('GIT_STACK_USER', ENV.fetch('USER'))
end

def upstream
  upstream = ARGV[0]
  raise ArgumentError, "missing argument: upstream" unless upstream
  upstream
end

def git_stack_sync_commit(commit, branches)
  targets = `git notes show #{commit} 2> /dev/null`.strip.split(',')

  return unless $?.success?

  targets.each do |target|
    if branches.include?(target)
      system("git checkout -q #{target}", exception: true)
    else
      system("git checkout -q #{upstream} -fB #{target}", exception: true)
      branches << target
    end

    system("git cherry-pick #{commit}", exception: true)
  end
end

def git_stack_sync
  commits = `git log --pretty=format:"%h" #{upstream}..#{user}/main`

  system("git stash push -q", exception: true)
  system("git checkout -q #{user}/main", exception: true)

  branches = []

  commits.split(/\s+/).reverse.each do |commit|
    git_stack_sync_commit(commit, branches)
  end

  branches += JSON.parse(File.read("#{ENV['HOME']}/.git-stack-branches")) rescue []

  system("git checkout -q #{user}/main", exception: true)

  branches = branches.uniq

  File.write("#{ENV['HOME']}/.git-stack-branches", branches.to_json)
end

def git_stack_rebase
  system("git stash push -q", exception: true)
  system("git checkout -q #{user}/main", exception: true)
  system("git fetch #{upstream.split('/').join(' ')}", exception: true)
  system("git rebase -i #{upstream} --autosquash", exception: true)
end

def git_stack_push_branch(branch)
  diff = `git diff origin/#{branch}..#{branch} 2> /dev/null`

  if $?.success? && diff.empty?
    puts "No changes for #{branch}"
  else
    system("git push -fu origin #{branch}", exception: true)
  end
end

def git_stack_push
  commits = `git log --pretty=format:"%h" #{upstream}..#{user}/main`

  branches = commits.split(/\s+/).map do |commit|
    `git notes show #{commit} 2> /dev/null`.strip
  end

  branches.uniq.each do |branch|
    git_stack_push_branch(branch) if branch != ''
  end
end

def git_stack_clean
  commits = `git log --pretty=format:"%h" #{upstream}..#{user}/main`

  all_branches = File.open("#{ENV['HOME']}/.git-stack-branches") do |fd|
    JSON.load(fd)
  end

  branches = all_branches.select do |branch|
    `git rev-parse --verify #{branch} 2> /dev/null`
    $?.success?
  end

  branches -= commits.split(/\s+/).reverse.map do |commit|
    `git notes show #{commit} 2> /dev/null`.strip
  end

  branches = branches.uniq

  return if branches.empty?

  puts branches.join("\n")
  puts
  puts "Delete these branches? (Y/N)"

  return if STDIN.gets.strip.upcase != 'Y'

  puts

  branches.each do |branch|
    system("git branch -D #{branch}", exception: true, silent: true)
  end

  File.write("#{ENV['HOME']}/.git-stack-branches", (all_branches - branches).to_json)
end

def git_stack_log
  format = '%C(brightblue)%h %C(brightcyan)%as%C(brightyellow)% N%C(reset) %s %C(brightred)(%al)%d' 
  system("git log --date=relative --color=always -z --pretty=format:'#{format}' | tr -d '\n' | tr '\\0' '\n' | less -REXS")
end

def main
  command = ARGV.shift

  case command
  when 'sync'
    git_stack_sync
  when 'rebase'
    git_stack_rebase
  when 'push'
    git_stack_push
  when 'clean'
    git_stack_clean
  when 'log'
    git_stack_log
  else
    raise ArgumentError, "usage: git stack sync|rebase|push"
  end
rescue => e
  $stderr.puts("git: #{e.message}")
end

main
